
VVV good tutorial or bootcamp or interactive way to learn k8: https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-intro/


Installation Guide : https://minikube.sigs.k8s.io/docs/start/
Cheatsheet : https://kubernetes.io/docs/reference/kubectl/cheatsheet/
Youtube : CloudxLab Official
-------------------------------------------------------------

Step 1 : to run kubernetes cluster in local we need minikube which create 3 node cluster with 1 master and 2 slave nodes
```brew install minikube```

Step 2 : start minikube - this is used to start the cluster on our single node machine,
first time it installs kubernetes & kubectl command line tool to interact with master node of kubernetes or minikube
```minikube start```
``` minikube status ```
```  kubectl api-resources ``` to  see list of resource we can get info

Step 3: Create Resource like deployment, service, pods etc
``` kubectl create deployment nginx-dep --image=nginx ```
``` kubectl create namespace my_namespace ```
```  kubectl get deployments ```

Note : all these command will get resource in default namespace so you would require to add -n <namespace> to
see resources in that particular namespace


Service - used to setup network inside k* cluster
each homogeneous pod belongs to deployment and each deployment has service associated with it

It is used for communication amongst pods
exposing app to outside cluster (NodePort type service)
forward request from ingress

Default service type is clusterIp which support ingress request and pod communication

Step 4 : Now as you already created a deployment you can expose it to outside world using service
```kubectl expose deployment nginx-dep --type=NodePort --name=ex-nginx-service --port=80
```

``` kubectl get service ```


Step 5: Access the exposed service of type nodeport using url generated by following command

```` minikube service --url ex-nginx-service ```


Step 6: We can use config file to crete resources instead of remembering all these commands

kubectl apply -f <config>.yaml


Structure
apiVersion - use kubectl api-resources
Kind - kind of resource
metadata  - name, namespace dict
spec - based on type of resource spec will very ie for deployment replicas, template


Step 7 execute all these yaml file inside k8 folder and check the resources

kubectl get deployments -n dummynamespace

Note: pods are created with <deployment Name>- somehash not by pod name


List pods from all namespaces
```kubectl get pods --all-namespaces```


To see pods in particaular namespace
``` get pods --show-labels -n dummynamespace```

kubectl config current-context                       # display the current-context
kubectl config use-context my-cluster-name           # set the default context to my-cluster-name



Use of label

``` get pods --selector=group1=dummylabel --all-namespaces ```


# cleanup  delete all created resource in k8s resource folder

kubectl delete -f <directory or file name>

Problem:
Till now we are accessing the nginx or app via NodePort using ip address which is hard to remember so to resolve that we
need a dns

Solution: Ingress
- Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster
- it contains routing information for the traffic to be redirected, after the traffic enters inside the cluster
- we apply these routs in yml file and apply that file to create the ingress resource
- Ingress uses CusterIp so don't mention nodePort and type attribute inside service.yaml

Ingress Controller - applies ingress rules as configured in ingress resource Example: nginx-ingress
- run in a pod of same container


Client ------>  Minikube ---> Ingress Controller (BaseDns)
                                 |---------> /subdomain1 ---> Deployment1---> redirect request to one of the pod
                                 |---------> /subdomain2 ---> Deployment2---> redirect request to one of the pod


We need to enable the ingress controler by default we add nginx-controller

minikube addons enable ingress

```kubectl describe ingress -n dummynamespace```
```get pods -o wide -n dummynamespace ``` --see the vip prefex is same for all pod within the cluster


Step 7: Configure dns in system
sudo vim /etc/hosts
Add ip and the host address

In k8 cloud it will be configured in loadbalancer


Create secret in some namespace

kubectl create secret generic <name of secret resource - dummypassword1> --from-literal DUMMY_PASSWORD=dummypassword -n dummynamespace

kubectl get secret -n dummynamespace

kubectl edit secret <secretname>